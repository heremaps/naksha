# HISTORY

This document describes the new feature of implementing a real-time logical replicable history. The
history allows to review every state a feature in a space had in the past and to rewind back to any
previous state. It supports layer views (which effectively is branching) and tagging.

## Table layout

To enable versioning we modify the table layout, currently space tables created like:

```sql
CREATE TABLE IF NOT EXISTS ${schema}.${table}
(
    jsondata jsonb,
    geo      geometry(GeometryZ, 4326),
    i        BIGSERIAL
);
```

This is optionally appended by `deleted BOOLEAN DEFAULT FALSE`. We will change this statement like:

```sql
CREATE TABLE IF NOT EXISTS "${schema}"."${table}"
(
    jsondata      jsonb,
    geo           geometry(GeometryZ, 4326),
    i             int8 PRIMARY KEY NOT NULL,
    "action"      int2 CONSTRAINT NOT NULL CHECK ("action" >= 0 AND "action" <= 3),
    tnx           int8             NOT NULL,
    ts            timestamptz      NOT NULL,
    id            text COLLATE "C" NOT NULL,
    uuid          uuid             NOT NULL,
    puuid         uuid,
    lastUpdatedBy text COLLATE "C"
);
CREATE SEQUENCE IF NOT EXISTS "${schema}"."${table}_i_all_seq" AS int8 OWNED BY "${schema}"."${table}";
CREATE INDEX IF NOT EXISTS "${schema}"."${table}_tnx_idx" ON "${schema}"."${table}" USING btree (tnx DESC);
CREATE INDEX IF NOT EXISTS "${schema}"."${table}_ts_idx" ON "${schema}"."${table}" USING btree (ts DESC);
CREATE INDEX IF NOT EXISTS "${schema}"."${table}_id_idx" ON "${schema}"."${table}" USING btree (id ASC);
CREATE UNIQUE INDEX IF NOT EXISTS "${schema}"."${table}_uuid_idx" ON "${schema}"."${table}" USING btree (uuid DESC);
CREATE INDEX IF NOT EXISTS "${schema}"."${table}_lub_idx" ON "${schema}"."${table}" USING btree (lastUpdatedBy ASC);
```

**Note**: We name the new `i` sequence `i_all_seq` by intension to stay downward compatible to old
spaces that should not be updated to new table layout. For these spaces, there then will be the 
old `i_seq` used for the automatically created `BIGSERIAL`, so the new `i_all_seq` does not 
conflict.

Possible actions are:

- `0`: CREATE
- `1`: UPDATE
- `2`: DELETE
- `3`: PURGE

The values for `i`, `action`, `tnx`, `ts`, `id`, `uuid` and `lastUpdatedBy` will be set
automatically by triggers, therefore they should not impact correct old insert statements.

**Note**: We allow downward compatible old tables where `i` is a `BIGSERIAL`, in that case other
triggers will be attached that will use a different `i` value in history than in **HEAD** table.
These old tables that are not updated will have a couple of not supported features, like they can't
act as overlays (delta-spaces) for views, because they are missing the `action` attribute. 
Additionally, they will not report the transaction identifiers and the `i` encoded in the **UUID**
will not be the same as the one taken from the **HEAD** table.

## Transaction Identifiers

Within every space we need all changes to have the same unique transaction identifier. The
transaction identifier used here will only be locally unique, so within a given space, but not
globally. For globally unique transaction identifiers, the transaction can be queries in the global
transaction table, where a unique `id` is generated.

The full qualified transaction identifier is created in a trigger, the layout of the 64-bit integer
is:

```
YYYY_YYYY-YYYY_MMMM-DDDD_DHHH-HHMM_MMMM--XXXX_XXXX-XXXX_XXXX-VVVV_xxxx-xxxx_xxxx

YYYY::12 (<<52) = biased year (year - 2000), resulting in possible years 2000 to 4047.
MMMM::4  (<<48) = month of the year (1 to 12)
DDDD::5  (<<43) = day of the month (1 to 31)
HHHH::5  (<<38) = hour of the day (0 to 23)
MMMM::6  (<<32) = minute of the hour (0 to 59)
XXXX::16 (<<16) = the bit 12 to 23 of of the current PostgresQL transaction id (high 16 bits)
VVVV::4  (<<12) = the fixed 4-bit binary value 4 (binary 1000), added to be compatible with UUID
xxxx::12        = the bit 0 to 11 of the current PostgresQL transaction id (low 12 bit)
```

Basically, the current PostgresQL transaction identifier will be read by the trigger via
`txid_current()` and then masked for the lower 28 bit, for example
`(txid_current() & x'fffffff'::int8)`.

We are aware of the problem of a 
[transaction wrap-around](https://www.postgresql.org/docs/current/routine-vacuuming.html), however, 
as we only rely upon the transaction number to create a unique identifier within a minute we expect
that even when a transaction wrap-around happens in a minute, we do not get any duplicates, except
there a billion of transactions per minute happen.

## UUIDs

The `UUID`s which are used by XYZ-Hub to uniquely identify features, is generated by triggers. We
modified this behavior to be done by the trigger to ensure that even queries executed in the 
database directly update the `UUID` of the features.

The **UUID** will be a [random UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier),
so being version 4, variant 1 (big endian encoded). This matches perfectly well with how PostgresQL
does [compare UUIDs](https://doxygen.postgresql.org/uuid_8c.html#aae2aef5e86c79c563f02a5cee13d1708).
As seen in the source code, the compare of **UUID**s is done as:

```C
return memcmp(arg1->data, arg2->data, UUID_LEN);
```

[memcp](https://cplusplus.com/reference/cstring/memcmp/) does compare simply the bytes in order 
(so basically using big-endian order). This is the binary layout of the generated **UUID**s is
therefore:

```
   1   2     3    e    4    5    6    7 -   e    8    9    b-   4    2    d    3 -   a    4    5    6-   4    2    6    6     1    4    1    7    4    0    0    0
|          time low                   |  |    time mid     | |v | | time high  |  a||  clock_seq     |              node                                          |
7654_3210-7654_3210-7654_3210-7654_3210--7654_3210-7654_3210-7654_3210-7654_3210--7654_3210-7654_3210-7654_3210-7654_3210--7654_3210-7654_3210-7654_3210-7654_3210
YYYY_YYYY-YYYY_MMMM-DDDD_DHHH-HHMM_MMMM--XXXX_XXXX-XXXX_XXXX-1000_XXXX-XXXX_XXXX--10ii_iiii-iiii_iiii-iiii_iiii-iiii_iiii--iiii_iiii-iiii_iiii-iiii_iiii-iiii_iiii
| year       | |mo| |day ||hour||min  |  |    tnx high     | |v | | tnx low    |  a||                      i (60 bit)                                             |
                                                              =4                  =1
```

**Note**:
- The version (`v`) is always four with value being 4 (binary `1000`).
- The variant (`a`) is always variant one (big endian) with value being decimal 2 (binary `10`).

We can create a byte array with this layout in our trigger and then cast it into a real version 4,
variant 1 **UUID** via: `CAST(ENCODE(bytes, 'hex') AS UUID)`.

## Transaction History

To enable the history we need a shared transaction table in the `xyz_config` schema:

```sql
CREATE TABLE IF NOT EXISTS xyz_config.transactions
(
    i           BIGSERIAL PRIMARY KEY,
    id          int8,
    tnx         int8             NOT NULL,
    "schema"    text COLLATE "C" NOT NULL,
    "table"     text COLLATE "C" NOT NULL,
    ts          timestamptz      NOT NULL,
    space       text COLLATE "C" UNIQUE,
    commit_msg  text COLLATE "C",
    commit_json jsonb
);
CREATE SEQUENCE IF NOT EXISTS xyz_config.transactions_id_seq AS int8 OWNED BY xyz_config.transactions;
CREATE UNIQUE INDEX IF NOT EXISTS xyz_config.transactions_is_idx
    ON xyz_config.transactions USING btree ("id" DESC, "space" DESC);
CREATE UNIQUE INDEX IF NOT EXISTS xyz_config.transactions_tst_idx
    ON xyz_config.transactions USING btree ("tnx" DESC, "schema" ASC, "table" ASC);
CREATE UNIQUE INDEX IF NOT EXISTS xyz_config.transactions_id_idx
    ON xyz_config.transactions USING btree (id DESC);
CREATE INDEX IF NOT EXISTS xyz_config.transactions_tnx_idx 
    ON xyz_config.transactions USING btree (tnx DESC);
CREATE INDEX IF NOT EXISTS xyz_config.transactions_ts_idx 
    ON xyz_config.transactions USING btree (ts DESC);
```

## Create history

To manage the history we will add triggers to all spaces. Basically, there are two variants of the
triggers, a downward compatible one, which will expect the old **HEAD** table layout and a new 
one, that expects the new table layout.

To be downward compatible to Map Creator Middleware, the triggers will ensure at least some 
[property modifications](https://confluence.in.here.com/pages/viewpage.action?pageId=800919496#property-modification-done-by-the-map-creator-middleware) 
done by the middleware. To be exact, we will set 
`jsondata->'properties'->'@ns:com:here:mom:meta'->'lastUpdatedTS'` and, if appropriate, the
`jsondata->'properties'->'@ns:com:here:mom:meta'->'createdTS'` to 

to keep it in sync with the `ts` column.

The triggers will as well maintain the XYZ namespace, so they will set in
`jsondata->'properties'->'@ns:com:here:xyz'` the following properties:
- **uuid** to the calculated UUID, the same value is written into the `uuid` column.
- **puuid** to the previous UUID, the same value is written into the `puuid` column.
- **createAt** to the [clock_timestamp()](https://www.postgresql.org/docs/8.2/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT), if this is an `INSERT`.
- **updatedAt** to the [clock_timestamp()](https://www.postgresql.org/docs/8.2/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT), if this is an `UPDATE` or `DELETE`.

### Triggers code

Note, the triggers for downward compatibility will be the same, except that they are missing 

```sql
-- Create a unique transaction identifier from the given UTC timestamp and the given transaction id.
CREATE OR REPLACE FUNCTION xyz_tnx_of(ts timestamptz, txid int8)
    RETURNS int8
    LANGUAGE plpgsql IMMUTABLE 
    AS $$
DECLARE
    r record;
    tid int8 := (txid & x'fffffff'::int8);
BEGIN
    WITH parts AS (SELECT EXTRACT(year from ts)::int8   as "year",
                          EXTRACT(month from ts)::int8  as "month",
                          EXTRACT(day from ts)::int8    as "day",
                          EXTRACT(hour from ts)::int8   as "hour",
                          EXTRACT(minute from ts)::int8 as "minute")
    SELECT parts.* INTO r FROM parts;
    RETURN ((r.year - 2000) << 52)
               | (r.month << 48)
               | (r.day << 43)
               | (r.hour << 38)
               | (r.minute << 32)
               | ((tid >> 12) << 16)
               | (4::int8 << 12)
               | (tid & x'fff'::int8);
END;
$$;

-- Create the minimal unique transaction identifier for the given UTC timestamp.
CREATE OR REPLACE FUNCTION xyz_tnx_min(ts timestamptz)
    RETURNS int8
    LANGUAGE 'plpgsql' IMMUTABLE
AS $$
BEGIN
    RETURN xyz_tnx_of(ts, 0::int8);
END
$$;

-- Create the maximal unique transaction identifier for the given UTC timestamp.
CREATE OR REPLACE FUNCTION xyz_tnx_max(ts timestamptz)
    RETURNS int8
    LANGUAGE 'plpgsql' IMMUTABLE
AS $$
BEGIN
    RETURN xyz_tnx_of(ts, x'7fffffffffffffff'::int8);
END
$$;

-- Create the unique transaction identifier for the current transaction.
CREATE OR REPLACE FUNCTION xyz_tnx_current()
    RETURNS int8
    LANGUAGE 'plpgsql' STABLE
    AS $$
BEGIN
    RETURN xyz_tnx_of(current_timestamp, txid_current());
END
$$;

-- Split the given unique transaction identifier into its part.
CREATE OR REPLACE FUNCTION xyz_tnx_extract(tnx int8)
    RETURNS TABLE
            (
                year    int8,
                month   int8,
                day     int8,
                hour    int8,
                minute  int8,
                txid    int8
            )
    LANGUAGE 'plpgsql' IMMUTABLE 
AS
$$
BEGIN
    RETURN QUERY SELECT 2000 + ((tnx >> 52) & x'ff'::int8)                           as "year",
                        ((tnx >> 48) & x'f'::int8)                                   as "month",
                        ((tnx >> 43) & x'1f'::int8)                                  as "day",
                        (tnx >> 38) & x'1f'::int8                                    as "hour",
                        (tnx >> 32) & x'3f'::int8                                    as "minute",
                        (((tnx >> 16) & x'ffff'::int8) << 12 | (tnx & x'fff'::int8)) as "txid";
END;
$$;

-- Create a UUID from the given unique transaction identifier and the given sequence.
CREATE OR REPLACE FUNCTION xyz_uuid_of(tnx int8, i int8)
    RETURNS uuid
    LANGUAGE 'plpgsql' IMMUTABLE
    AS
$BODY$
DECLARE
    raw_uuid bytea; 
BEGIN
    raw_uuid := set_byte('\x00000000000000000000000000000000'::bytea, 0, ((tnx >> 56) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 1, ((tnx >> 48) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 2, ((tnx >> 40) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 3, ((tnx >> 32) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 4, ((tnx >> 24) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 5, ((tnx >> 16) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 6, ((tnx >> 8) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 7, (tnx & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 8, (((i >> 56) & x'3f'::int8) | 128)::int);
    raw_uuid := set_byte(raw_uuid, 9, ((i >> 48) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 10, ((i >> 40) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 11, ((i >> 32) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 12, ((i >> 24) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 13, ((i >> 16) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 14, ((i >> 8) & x'ff'::int8)::int);
    raw_uuid := set_byte(raw_uuid, 15, (i & x'ff'::int8)::int);
    RETURN CAST(ENCODE(raw_uuid, 'hex') AS UUID);
END
$BODY$;
```

## Transaction Fixation Job

The last step is a background job added into XYZ-Hub that will fix the global transaction table.
it need to guarantee a unique sequential `id` for all transactions. 

## Fix HRN

Add "default HRN" to space table, so that identifiers in tables never have this prefix.
