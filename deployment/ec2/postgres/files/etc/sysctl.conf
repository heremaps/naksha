#
# /etc/sysctl.conf - Configuration file for setting system variables
# See /etc/sysctl.d/ for additional system variables.
# See sysctl.conf (5) for information.
# See https://man7.org/linux/man-pages/man5/sysctl.conf.5.html
#

#kernel.domainname = example.com

# Uncomment the following to stop low-level messages on console
#kernel.printk = 3 4 1 3

###################################################################
# Magic system request Key
# 0=disable, 1=enable all, >1 bitmask of sysrq functions
# See https://www.kernel.org/doc/html/latest/admin-guide/sysrq.html
# for what other values do
#kernel.sysrq=438

# Increase number of explicit huge pages (each 2 MiB)
vm.nr_hugepages = 0

# maximum number of file-handles that the Linux kernel will allocate.
# We use 64 per mb of memory
fs.file-max = 16777216   # = 1024 * 1024 * 16 (for 1 TB of memory)

# The maximum number of memory map areas a process may have. Default is 65536, each map costs ~128 byte. ZGC uses a lot!
vm.max_map_count = 524288 # Consumes 64mb of memory

# Only swap when we're totally out of memory (we want to use all memory)
# Note: The kernel will still swap code areas, because they're anyway read from disk!
vm.swappiness = 0

# As applications write to files, the page cache becomes dirty and the buffer cache may become dirty.
# When the amount of dirty memory reaches a specified number of pages in bytes (vm.dirty_background_bytes),
# or when the amount of dirty memory reaches a specific ratio to total memory (vm.dirty_background_ratio),
# or when the pages have been dirty for longer than a specified amount of time (vm.dirty_expire_centisecs),
# the kernel begins write back of pages starting with files that had the pages dirtied first. The background
# bytes and ratios are mutually exclusive and setting one will overwrite the other. Flusher threads perform
# write back in the background and allow applications to continue running. If the I/O cannot keep up with
# applications dirtying page cache, and dirty data reaches a critical setting (vm.dirty_bytes or vm.dirty_ratio),
# then applications begin to be throttled to prevent dirty data exceeding this threshold.
vm.dirty_ratio = 80
vm.dirty_background_ratio = 2

# Sets the time before the kernel considers migrating a process to another core
kernel.sched_migration_cost_ns = 5000000 # 5 millis

# Values are:
#
#   0: heuristic overcommit (this is the default)
#   1: always overcommit, never check
#   2: always check, never overcommit
#
# In mode 0, calls of mmap(2) with MAP_NORESERVE are not checked, and the default check is very
# weak, leading to the risk of getting a process "OOM-killed".
#
# In mode 2 (available since Linux 2.6), the total virtual address space that can be allocated
# (CommitLimit in /proc/mem‐info) is calculated as
#    CommitLimit = (total_RAM - total_huge_TLB) *
#                  overcommit_ratio / 100 + total_swap
# Note: If not 1, then forking a process can fail, when not enough memory is available, even while
#       the forked process might not change any memory (read-only) and therefore does not need a
#       copy of the memory
# See:  https://redis.io/docs/getting-started/faq/
vm.overcommit_memory = 1

# Max number of connection requests that can be queued for any given listening socket.
net.core.somaxconn = 65536

# https://confluence.in.here.com/display/SPC/General-hardening
# 0 – Do not randomize stack and vdso page.
# 1 – Turn on protection and randomize stack, vdso page and mmap.
# 2 – Turn on protection and randomize stack, vdso page and mmap + randomize brk base address.
kernel.randomize_va_space = 2

# https://confluence.in.here.com/display/SPC/General-hardening
#kernel.exec-shield=2
# Not needed: https://wiki.ubuntu.com/Security/Features#nx

# Set default/max receive and send tcp buffer sizes in bytes.
# Using "bandwidth delay product" to estimate default and maximum:
# (Gbps * 2^27) * (delay in seconds / 1000) / 2^20 = size in mb
# (Mbps * 2^17) * (delay in seconds / 1000) / 2^20 = size in mb
#
# ultra:    200 Gbps *   1 millis = 25.00 GiB/s * 0,001s = 25.60mb
# high:     100 Gbps *   2 millis = 12.50 GiB/s * 0,002s = 25.60mb
# good:      10 Gbps *   5 millis =  1.25 GiB/s * 0,005s =  6.40mb
# intranet:   1 Gbps *  50 millis =   125 MiB/s * 0,050s =  6.40mb
# internet:  50 Mbps * 200 millis =  6.25 MiB/s * 0,200s =  1.25mb
net.core.rmem_default = 5242880   # bytes (= 5mb)
net.core.wmem_default = 5242880
net.core.rmem_max = 33554432     # bytes (= 32mb)
net.core.wmem_max = 33554432

# Amount of memory in bytes for read (receive) and write (transmit) buffers per open socket.
#                   minimum  pressure  maximum
net.ipv4.tcp_rmem = 8192 10485760 33554432
net.ipv4.tcp_wmem = 8192 10485760 33554432
#                   8kb  10mb     32mb

# Amount of memory in pages (~4096-byte, see `getconf PAGE_SIZE`) totaled across all TCP applications.
# Note: "pressure" is the threshold at which TCP will start to reclaim buffer memory to move memory
#       use down toward the minimum. You want to avoid hitting that threshold.
#                   minimum  pressure  maximum   | 256 = 1mb
net.ipv4.tcp_mem = 2097152 4194304 6291456
#                  8gb     16gb    24gb

# TCP Selective Acknowledgement (TCP SACK) allows the receiving side to give the sender more
# detail about lost segments, reducing volume of retransmissions.
net.ipv4.tcp_sack = 1   # TCP SACK (TCP Selective Acknowledgement)
net.ipv4.tcp_dsack = 1  # DSACK (duplicate TCP SACK)
net.ipv4.tcp_fack = 0   # FACK (Forward Acknowledgement)

# TCP slow start after idle connection
net.ipv4.tcp_slow_start_after_idle = 0

# TFO - TCP fast open
# 0 = TFO is not enabled.
# 1 = TFO is enabled for outgoing connections (clients).
# 2 = TFO is enabled for incoming connections (servers).
# 3 = TFO is enabled for both clients and servers.
net.ipv4.tcp_fastopen = 3

# Increase number of available local ports to 47,500.
net.ipv4.ip_local_port_range = 18000 65500                # default is: 32768  60999

# We do not want to keep sockets for too long in TIME_WAIT, with the default value of 120 we're out of sockets
# at 400 sockets per second (400 * 120 = 48000). With just 30 seconds, we can handle up to 1,600 sockets per second.
net.netfilter.nf_conntrack_tcp_timeout_time_wait = 30     # default is 120

# Watch /var/log/syslog if we reach this limit, because if we do, iptables will just stop accepting new connections!
net.nf_conntrack_max = 262144

# The amount of seconds connections stay in iptables conntrack in seconds.
net.netfilter.nf_conntrack_tcp_timeout_established = 600  # default is 432000 (5 days)

# cat /proc/sys/net/ipv4/tcp_available_congestion_control
# see: https://en.wikipedia.org/wiki/TCP_congestion_control#TCP_CUBIC
net.ipv4.tcp_congestion_control = cubic

# Wait time in seconds between isAlive interval probes.
net.ipv4.tcp_keepalive_intvl = 5       # default: 75
# How many keepalive probes to send out before the socket is timed out.
net.ipv4.tcp_keepalive_probes = 5       # default: 9
# Set the TCP Socket timeout value in seconds.
net.ipv4.tcp_keepalive_time = 300       # default: 7200 | 2 hours

# Configure TCP for low latency, favoring low latency over throughput.
net.ipv4.tcp_low_latency = 1            # default: 0

# Limit number of orphans, each orphan can eat up to 16M (max wmem) of unswappable memory.
net.ipv4.tcp_max_orphans = 16384        # default: 262144

# Maximal number of timewait sockets held by system simultaneously. If this number is
# exceeded time-wait socket is immediately destroyed and warning is printed.
# This limit exists to help prevent simple DoS attacks.
net.ipv4.tcp_max_tw_buckets = 262144   # default: 262144

# By default, TCP saves various connection metrics in the route cache when the connection closes, so that
# connections established in the near future can use these to set initial conditions. Usually, this
# increases overall performance, but may sometimes cause performance degradation. If set, TCP will not
# cache metrics on closing connections.
net.ipv4.tcp_no_metrics_save = 1

# Use large TCP windows.
net.ipv4.tcp_window_scaling = 1

# Dynamically adjusts the TCP buffer size
net.ipv4.tcp_moderate_rcvbuf = 1

# Before processing the data by the TCP/UDP layer, the system puts the data in the kernel queue.
# Set the maximum number of packets to put in the queue before delivery to the upper layer.
# For a 200 Gbps network, the default of 1000 is too small and can lead to paket drops!
net.core.netdev_max_backlog = 65536

# Increase the maximum amount of option memory buffers
net.core.optmem_max = 1048576 # 1mb, default is 20480 byte (too few for Tbps)

# Time to wait for FINACK in seconds.
net.ipv4.tcp_fin_timeout = 10   # default is 60 seconds

# IP Spoofing protection
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.all.rp_filter = 1

# Enable/disable TCP/IP SYN cookies; this may impact IPv6 TCP sessions too.
# See http://lwn.net/Articles/277146/
# See https://linux2me.wordpress.com/2018/06/03/tuning-the-tcp-stack-system-administrator/
#
# Many default Linux installations use SYN cookies to protect the system against malicious
# attacks that flood TCP SYN packets. The use of SYN cookies dramatically reduces network bandwidth.
# NOTE: if SYN floods are an issue and SYN cookies can’t be disabled, try the following:
# net.ipv4.tcp_max_syn_backlog = 16384
# net.ipv4.tcp_synack_retries = 1
# net.ipv4.tcp_max_orphans = 400000
net.ipv4.tcp_syncookies = 0

# Protect Against TCP Time-Wait
# net.ipv4.tcp_rfc1337 = 1

# Controls IP packet forwarding
net.ipv4.ip_forward = 0
# Enabling this option disables Stateless Address Autoconfiguration based on Router Advertisements for this host
net.ipv6.conf.all.forwarding = 0

# Do not accept ICMP redirects (prevent MITM attacks)
net.ipv4.conf.all.accept_redirects = 0
net.ipv6.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv6.conf.default.accept_redirects = 0

# Accept ICMP redirects only for gateways listed in our default
# gateway list (enabled by default)
net.ipv4.conf.all.secure_redirects = 1
net.ipv4.conf.default.secure_redirects = 1

# Do not send ICMP redirects (we are not a router)
net.ipv4.conf.all.send_redirects = 0

# Do not accept IP source route packets (we are not a router)
net.ipv4.conf.all.accept_source_route = 0
net.ipv6.conf.all.accept_source_route = 0

# Ignore send redirects
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0

# Disable source packet routing
net.ipv4.conf.all.accept_source_route = 0
net.ipv6.conf.all.accept_source_route = 0
net.ipv4.conf.default.accept_source_route = 0
net.ipv6.conf.default.accept_source_route = 0

# Log Martian Packets
net.ipv4.conf.all.log_martians = 1

# Block SYN attacks
net.ipv4.tcp_max_syn_backlog = 2048
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_syn_retries = 5

# Log Martians
net.ipv4.icmp_ignore_bogus_error_responses = 1

# Ignore ICMP broadcast requests
net.ipv4.icmp_echo_ignore_broadcasts = 1

# Ignore Directed pings
net.ipv4.icmp_echo_ignore_all = 1
kernel.exec-shield = 1
kernel.randomize_va_space = 1

# disable IPv6 if required (IPv6 might cause issues with the Internet connection being slow)
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
net.ipv6.conf.lo.disable_ipv6 = 1

# [IPv6] Number of Router Solicitations to send until assuming no routers are present.
# This is host and not router.
net.ipv6.conf.default.router_solicitations = 0

# Accept Router Preference in RA?
net.ipv6.conf.default.accept_ra_rtr_pref = 0

# Learn prefix information in router advertisement.
net.ipv6.conf.default.accept_ra_pinfo = 0

# Setting controls whether the system will accept Hop Limit settings from a router advertisement.
net.ipv6.conf.default.accept_ra_defrtr = 0

# Router advertisements can cause the system to assign a global unicast address to an interface.
net.ipv6.conf.default.autoconf = 0

# How many neighbor solicitations to send out per address?
net.ipv6.conf.default.dad_transmits = 0

# How many global unicast IPv6 addresses can be assigned to each interface?
net.ipv6.conf.default.max_addresses = 1

# In rare occasions, it may be beneficial to reboot your server reboot if it runs out of memory.
# This simple solution can avoid you hours of down time. The vm.panic_on_oom=1 line enables panic
# on OOM; the kernel.panic=10 line tells the kernel to reboot ten seconds after panicking.
vm.panic_on_oom = 1
kernel.panic = 10
