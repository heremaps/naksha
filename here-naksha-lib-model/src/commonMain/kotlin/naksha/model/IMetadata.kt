package naksha.model

import naksha.base.Int64

/**
 * Interface to read the metadata of a [Tuple], generated by the storage.
 */
interface IMetadata {
    /**
     * The storage-number, a unique identifier of the storage.
     * @since 3.0.0
     */
    val storageNumber: Int64

    /**
     * The store-number, which encodes the map-number, collection-number, and the partition-number.
     *
     * If the client wants to create metadata for internal purpose or to create a new feature, then it should use [UNDEFINED_STORE_NUMBER].
     * @since 3.0.0
     */
    val storeNumber: StoreNumber

    /**
     * The epoch milliseconds when the feature was last updated (modified).
     * @since 3.0.0
     */
    val updatedAt: Int64

    /**
     * The epoch milliseconds when the feature was created.
     * @since 3.0.0
     */
    val createdAt: Int64

    /**
     * The epoch milliseconds when the author changed.
     * @since 3.0.0
     */
    val authorTs: Int64

    /**
     * The next version, if a newer one is known.
     *
     * This is the transaction number of the transaction that contains the next state of the feature.
     *
     * If not being _null_, then the next state can be found by searching for the row that have the [prevVersion] set to the [version] of this row, and the [puid] set to the [uid] of this row. Note that there is no direct reference to the new [uid], therefore [id] and [nextVersion] have to be used to find the next state, if desired.
     *
     * If this is _null_, there is no guarantee that the state has not changed meanwhile, so this should be seen as the last known information, not an immutable value.
     * @since 3.0.0
     */
    var nextVersion: Version?

    /**
     * The version of the row.
     *
     * This is the transaction number of the transaction in which this row was created, so the transaction to which this row belongs.
     *
     * If the client wants to create metadata for internal purpose or to create a new feature, then it should use [Version.UNDEFINED].
     * @since 3.0.0
     */
    val version: Version

    /**
     * The previous version.
     *
     * This is the transaction number of the transaction that contains the previous state of the feature; if _null_, the state should be [CREATED][Action.CREATED], if not _null_ [UPDATED][Action.CREATED] or [DELETED][Action.DELETED].
     * @since 3.0.0
     */
    val prevVersion: Version?

    /**
     * The transaction local identifier of this row.
     * @since 3.0.0
     */
    val uid: Int

    /**
     * The transaction local identifier of the previous row.
     * @since 3.0.0
     */
    val puid: Int?

    /**
     * The Naksha storage hash about the feature.
     * @since 3.0.0
     */
    val hash: Int

    /**
     * The amount of changes done to the feature, the counter starts with 1.
     * @since 3.0.0
     */
    val changeCount: Int

    /**
     * The binary [HERE tile number][naksha.geo.HereTile] calculated from the [Tuple.referencePoint].
     * @since 3.0.0
     */
    val geoGrid: Int

    /**
     * The encoding flags.
     * @since 3.0.0
     */
    val flags: Flags

    /**
     * The feature-id.
     * @since 3.0.0
     */
    val id: String

    /**
     * The application identifier of the application that performed the last change.
     * @since 3.0.0
     */
    val appId: String

    /**
     * The last author that made a change at [authorTs].
     * @since 3.0.0
     */
    val author: String?

    /***
     * The feature type, if being _null_, the default type of the collection.
     *
     * The type is read from `properties.featureType`, `momType`, and eventually `type`.
     * @since 3.0.0
     */
    val type: String?

    /***
     * The origin, special property for rebasing.
     * @since 3.0.0
     */
    val origin: String?
}