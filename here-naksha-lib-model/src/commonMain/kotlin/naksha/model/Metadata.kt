@file:Suppress("OPT_IN_USAGE")

package naksha.model

import naksha.base.Fnv1a32
import naksha.base.Int64
import naksha.base.fn.Fn3
import naksha.geo.HereTile
import naksha.model.objects.NakshaFeature
import kotlin.js.JsExport
import kotlin.js.JsStatic
import kotlin.jvm.JvmStatic

/**
 * The on heap representation of the metadata of a [Tuple], normally generated by the storage, read-only for the client (except when creating new feature states). The metadata describes a specific immutable state of a feature, except the [_tupleNumber] is [TupleNumber.UNDEFINED], in that case the metadata describes new, not yet persisted, state.
 */
@JsExport
data class Metadata(
    override val storageNumber: Int64,
    override val storeNumber: StoreNumber,
    override val updatedAt: Int64,
    override val createdAt: Int64 = updatedAt,
    override val authorTs: Int64 = updatedAt,
    override var nextVersion: Version? = null,
    override val version: Version,
    override val prevVersion: Version? = null,
    override val uid: Int,
    override val puid: Int? = null,
    override val hash: Int = 0,
    override val changeCount: Int = 1,
    override val geoGrid: Int = 0,
    override val flags: Flags,
    override val id: String,
    override val appId: String,
    override val author: String?,
    override val type: String?,
    override val origin: String? = null
) : IMetadata {
    private var _guid: Guid? = null

    /**
     * Tests if this describes a new state.
     * @return _true_ if this describes a new state, not yet persisted; _false_, if it describes an existing state.
     */
    fun isNew(): Boolean = tupleNumber() == TupleNumber.UNDEFINED

    /**
     * Returns the [Guid].
     * @return the [Guid].
     */
    fun guid(): Guid {
        var i = _guid
        if (i == null) {
            i = Guid(id, tupleNumber())
            _guid = i
        }
        return i
    }

    private var _tupleNumber: TupleNumber? = null

    /**
     * Return the tuple-number.
     * @return the tuple-number.
     */
    fun tupleNumber(): TupleNumber {
        var i = _tupleNumber
        if (i == null) {
            i = TupleNumber(storageNumber, storeNumber, version, uid, flags)
            _tupleNumber = i
        }
        return i
    }

    /**
     * Extracts the action from [flags] and return the enumeration value.
     * @return the enumeration value of action, extracted from [flags].
     */
    fun action() : Action = when (flags.action()) {
        ActionValues.CREATED -> Action.CREATED
        ActionValues.UPDATED -> Action.UPDATED
        ActionValues.DELETED -> Action.DELETED
        else -> Action.UNKNOWN
    }

    override fun hashCode(): Int = tupleNumber().hashCode()
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Metadata) return false
        // If the features are stored in different storages, they can't be the equal.
        if (storeNumber != other.storeNumber) return false
        val tupleNumber = tupleNumber()
        // If they have different tuple-numbers, the feature-states can't be the same.
        if (tupleNumber != other.tupleNumber()) return false
        // The features are in the same state, except they are both new (having undefined tuple-number),
        //   then they are in the same state only, when they have the same id.
        return tupleNumber != TupleNumber.UNDEFINED || id == other.id
    }
    override fun toString(): String = "$id:$_tupleNumber"

    companion object Metadata_C {
        /**
         * Calculates the feature hash to be stored in [Metadata].
         * @param feature the feature.
         * @param excludePaths an optional list of paths to exclude.
         * @param excludeFn an optional function to call for the [feature], current path, current value to decide if the value should be excluded from hashing.
         * @return the hash.
         */
        @JvmStatic
        @JsStatic
        fun hash(
            feature: NakshaFeature,
            excludePaths: List<Array<String>>? = null,
            excludeFn: Fn3<Boolean, NakshaFeature, List<String>, Any?>? = null
        ): Int {
            // TODO: We need to calculate the hash above the feature itself.
            //  - Order keys first.
            //  - Exclude the given paths
            //  - Always exclude ["properties", "@ns:com:here:xyz"]
            //  - The purpose of the hash is to find similar entries
            //    - We only care about real data changes (not times, author, other metadata)
            return Fnv1a32.string(0, feature.id)
        }

        /**
         * Calculate the geo-grid value for [Metadata].
         * @param feature the feature for which to calculate the geo-grid.
         * @return the geo-grid value.
         */
        @JvmStatic
        @JsStatic
        fun geoGrid(feature: NakshaFeature): Int {
            val c = feature.referencePoint ?: feature.geometry?.calculateCentroid()
            return if (c != null) HereTile(c.latitude, c.longitude).intKey else Fnv1a32.string(0, feature.id)
        }
    }
}