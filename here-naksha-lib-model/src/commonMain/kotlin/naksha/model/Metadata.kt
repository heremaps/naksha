@file:Suppress("OPT_IN_USAGE")

package naksha.model

import naksha.base.Int64
import kotlin.js.JsExport
import kotlin.jvm.JvmField

/**
 * The metadata of a [Row], generated by the storage, read-only for the client.
 *
 * Every row in the storage does have a unique [row address][RowAddr], that is made out of [txn], [uid], and [flags].
 */
@JsExport
data class Metadata(
    /**
     * The epoch milliseconds when the feature was created.
     */
    @JvmField
    val createdAt: Int64,

    /**
     * The epoch milliseconds when the feature was last updated (modified).
     */
    @JvmField
    val updatedAt: Int64,

    /**
     * The epoch milliseconds when the author changed.
     */
    @JvmField
    val authorTs: Int64,

    /**
     * The transaction number of the transaction that contains the next state of this feature.
     *
     * If not being _null_, then the next state can be found in the transaction with this transaction number, by searching for the row that have the [ptxn] set to the [txn] of this row, and the [puid] set to the [uid] of this row. Note that there is no direct reference to the new [uid], therefore [id] and [txnNext] have to be used to find the next state, if desired.
     */
    @JvmField
    val txnNext: Int64?,

    /**
     * The transaction number of the transaction in which this state was created, so the transaction to which this row belongs.
     */
    @JvmField
    val txn: Int64,

    /**
     * The transaction number of the previous transaction that contains the previous state of this row; if _null_, the state should be [CREATED][ActionEnum.CREATED], if not _null_ [UPDATED][ActionEnum.CREATED] or [DELETED][ActionEnum.DELETED].
     */
    @JvmField
    val ptxn: Int64?,

    /**
     * The transaction local identifier of this row.
     */
    @JvmField
    val uid: Int,

    /**
     * The transaction local identifier of the previous row.
     */
    @JvmField
    val puid: Int,

    /**
     * The Naksha storage hash about the feature.
     */
    @JvmField
    val hash: Int,

    /**
     * The amount of changes done to the feature, the counter starts with 1.
     */
    @JvmField
    val changeCount: Int,

    /**
     * The binary [HERE tile number][naksha.geo.HereTile] calculated from the [Row.referencePoint].
     */
    @JvmField
    val geoGrid: Int,

    /**
     * The encoding flags.
     */
    @JvmField
    val flags: Flags,

    /**
     * The application identifier of the application that performed the last change.
     */
    @JvmField
    val appId: String,

    /**
     * The last author that made a change at [authorTs].
     */
    @JvmField
    val author: String?,

    /**
     * The feature-type, extracted from `properties.featureType` or `type`.
     *
     * If _null_, then it is the default type of the collection, see [naksha.model.NakshaCollectionProxy.defaultType].
     */
    @JvmField
    val type: String?,

    /**
     * The feature-id.
     */
    @JvmField
    val id: String
) {

    /**
     * Create a transaction local unique identifier from this row.
     */
    fun getLuid() = Luid(Version(txn), uid)

    override fun hashCode(): Int {
        var result = createdAt.hashCode()
        result = 31 * result + updatedAt.hashCode()
        result = 31 * result + authorTs.hashCode()
        result = 31 * result + txnNext.hashCode()
        result = 31 * result + flags
        result = 31 * result + id.hashCode()
        result = 31 * result + (type?.hashCode() ?: 0)
        result = 31 * result + (meta?.hashCode() ?: 0)
        result = 31 * result + (feature?.contentHashCode() ?: 0)
        result = 31 * result + (geo?.contentHashCode() ?: 0)
        result = 31 * result + (referencePoint?.contentHashCode() ?: 0)
        result = 31 * result + (tags?.contentHashCode() ?: 0)
        return result
    }
    override fun equals(other: Any?): Boolean {

    }
}