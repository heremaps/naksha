@file:Suppress("OPT_IN_USAGE")

package naksha.model

import naksha.base.Int64
import kotlin.js.JsExport
import kotlin.jvm.JvmField

/**
 * The metadata of a [Row], generated by the storage, read-only for the client.
 *
 * Every row in the storage does have a unique [row identifier][RowId], that is made out of [version], [uid], and the partition number read form [flags].
 */
@JsExport
data class Metadata(
    /**
     * The epoch milliseconds when the feature was created.
     */
    @JvmField
    val createdAt: Int64,

    /**
     * The epoch milliseconds when the feature was last updated (modified).
     */
    @JvmField
    val updatedAt: Int64,

    /**
     * The epoch milliseconds when the author changed.
     */
    @JvmField
    val authorTs: Int64,

    /**
     * The next version, if a newer one is known.
     *
     * This is the transaction number of the transaction that contains the next state of the feature.
     *
     * If not being _null_, then the next state can be found by searching for the row that have the [prevVersion] set to the [version] of this row, and the [puid] set to the [uid] of this row. Note that there is no direct reference to the new [uid], therefore [id] and [nextVersion] have to be used to find the next state, if desired.
     *
     * If this is _null_, there is no guarantee that the state has not changed meanwhile, so this should be seen as the last known information, not an immutable value.
     */
    @JvmField
    var nextVersion: Int64?,

    /**
     * The version of the row.
     *
     * This is the transaction number of the transaction in which this row was created, so the transaction to which this row belongs.
     */
    @JvmField
    val version: Int64,

    /**
     * The previous version.
     *
     * This is the transaction number of the transaction that contains the previous state of the feature; if _null_, the state should be [CREATED][Action.CREATED], if not _null_ [UPDATED][Action.CREATED] or [DELETED][Action.DELETED].
     */
    @JvmField
    val prevVersion: Int64?,

    /**
     * The transaction local identifier of this row.
     */
    @JvmField
    val uid: Int,

    /**
     * The transaction local identifier of the previous row.
     */
    @JvmField
    val puid: Int,

    /**
     * The Naksha storage hash about the feature.
     */
    @JvmField
    val hash: Int,

    /**
     * The amount of changes done to the feature, the counter starts with 1.
     */
    @JvmField
    val changeCount: Int,

    /**
     * The binary [HERE tile number][naksha.geo.HereTile] calculated from the [Row.referencePoint].
     */
    @JvmField
    val geoGrid: Int,

    /**
     * The encoding flags.
     */
    @JvmField
    val flags: Flags,

    /**
     * The application identifier of the application that performed the last change.
     */
    @JvmField
    val appId: String,

    /**
     * The last author that made a change at [authorTs].
     */
    @JvmField
    val author: String?,

    /**
     * The feature-type, extracted from `properties.featureType` or `type`.
     *
     * If _null_, then it is the default type of the collection, see [naksha.model.objects.NakshaCollection.defaultType].
     */
    @JvmField
    val type: String?,

    /**
     * The feature-id.
     */
    @JvmField
    val id: String
) {
    private var rowId: RowId? = null

    /**
     * Return the row identifier.
     * @return the row identifier.
     */
    fun rowId(): RowId {
        var i = rowId
        if (i == null) {
            i = RowId(Version(version), uid, flags)
            rowId = i
        }
        return i
    }

    /**
     * Extracts the action from [flags] and return the enumeration value.
     * @return the enumeration value of action, extracted from [flags].
     */
    fun action() : Action = when (flags.action()) {
        ActionValues.CREATED -> Action.CREATED
        ActionValues.UPDATED -> Action.UPDATED
        ActionValues.DELETED -> Action.DELETED
        else -> Action.UNKNOWN
    }

    override fun hashCode(): Int = rowId().hashCode()
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Metadata) return false
        // Note: No, we did not forget "nextVersion" in this compare !!!
        //       Even when next-version is set eventually, the metadata should be treated as the same!
        return createdAt == other.createdAt
                && updatedAt == other.updatedAt
                && authorTs == other.authorTs
                && version == other.version
                && prevVersion == other.prevVersion
                && uid == other.uid
                && puid == other.puid
                && hash == other.hash
                && changeCount == other.changeCount
                && geoGrid == other.geoGrid
                && flags == other.flags
                && appId == other.appId
                && author == other.author
                && type == other.type
                && id == other.id
    }
    override fun toString(): String = "$id:$rowId"
}