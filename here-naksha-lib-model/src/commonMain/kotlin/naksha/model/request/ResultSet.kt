@file:Suppress("OPT_IN_USAGE", "MemberVisibilityCanBePrivate")

package naksha.model.request

import naksha.model.*
import kotlin.js.JsExport
import kotlin.math.max
import kotlin.math.min

/**
 * A result-set as generated by the storage, and returned for a [ReadRequest] or [ReadHandle].
 *
 * - For a [ReadHandle] actually the offset, and limit stored in it are read, then a new result-set is generated with an offset moved forward.
 * - For a [ReadRequest] the offset will always be zero.
 *
 * The result-set is not serializable itself, but the row identifiers are. The result-set provides access to storage internal caches, and allows a more fine-grained access to results. A result-set may contain more data than needed or requested by the client.
 */
@JsExport
interface ResultSet {

    /**
     * The storage that produces the result-set.
     */
    fun storage(): IStorage

    /**
     * The amount of rows that were requested by the client via [ReadRequest.limit]. If the client did not request any limit, the limit that the API selected.
     */
    fun limit(): Int

    /**
     * The maximum amount of rows that were requested from the storage.
     */
    fun hardCap(): Int

    /**
     * The offset in the result-set from where to read rows to make the result for the client.
     *
     * Will be zero, if the result-set was generated for a [ReadFeatures] request, bigger than zero, when the result-set was produced by a [ReadHandle] request.
     */
    fun offset(): Int

    /**
     * The position in the result-set that should not be included in the result.
     */
    fun end(): Int

    /**
     * Creates a result from all [rows], that should be part of the success response.
     *
     * **Note**: The storage will not fetch the rows of the result-rows, when there is no need to do this. Therefore, [IStorage.fetchRows] should be invoked ones for this result-row list.
     *
     * @return a sub-list from [offset] to [end] with all result-rows, that should be part of the success response.
     */
    fun result(): ResultRowList

    /**
     * Returns the size of the result, actually this is simply `result().size`.
     * @return the amount of rows being part of the result.
     */
    fun resultSize(): Int = result().size

    /**
     * Returns all [rows][Row] being part of the result-set, the rows may not have been read from the storage yet, and may require to invoke [IStorage.fetchRows]. Only the rows till [validationEnd] are validated (filtered), all others are in an unknown state, except [isComplete].
     *
     * To generate the features for an [SuccessResponse], simply read all rows from [offset] till [end] (or use the [result] method), and convert them into features. Beware that only the rows till [validationEnd] are reliable. All rows returned starting with the one at [validationEnd] are not yet validated, therefore some filters (like property query, lambdas) have not been applied yet.
     * @return the list of all rows being part of the result-set.
     */
    fun rows(): ResultRowList

    /**
     * The position in the result-set that was not yet validated.
     *
     * The client should not read beyond this position. It can force a validation by calling [validateTill], if it needs to process more rows of the result-set than the client requested (for whatever reason).
     */
    fun validationEnd(): Int

    /**
     * Force the storage to validate more rows.
     *
     * If the result-set is [incomplete][isIncomplete], the method will throw an [NakshaError.ILLEGAL_STATE] error.
     * @param end the position until which to validate the result-set, if `rows().size` is given, the result-set will become [complete][isComplete].
     * @param end the offset of the first row **not** to validate.
     */
    fun validateTill(end: Int)

    /**
     * If _true_, the result-set is complete, that means all [rows][Row] of the result-set are available, they are ordered correctly, and filtered by given [filter-lambdas][ResultFilter].
     */
    fun isComplete(): Boolean

    /**
     * If _true_, the result-set is complete, but not fully validated, this state is called partially complete. This means that all rows are ordered, but are only validated until [validationEnd], where [validationEnd] is the index of the first row not yet validated.
     *
     * Unless a specific ordering is requested or other circumstances, the storage normally only validates rows until enough are available to fulfill the [limit]. If this is a continuation read, it needs to filter everything up until [offset], and then enough for the [limit], so in this case [validationEnd] should be greater or equal to [offset] plus [limit].
     */
    fun isPartial(): Boolean

    /**
     * If _true_, the result-set only holds what the client requested, so [rows] will return exactly what the client requested.
     *
     * Note, if no handle, and no order where requested by the client, and a small limit was given, the storage may decide to only load the needed rows, therefore the result-set is incomplete. This means that [offset] will be zero, [end] and [validationEnd] will both be equal to `rows().size`.
     */
    fun isIncomplete(): Boolean

    /**
     * Creates a handle into the result-set, requires that the result-set is either [complete][isComplete] or [partially complete][isPartial], and that is valid until the given `end`.
     *
     * - If the given `end` is larger than [ResultSet.validationEnd], the method will throw an [NakshaError.ILLEGAL_STATE] error.
     * - If the result-set is [incomplete][isIncomplete], the method will throw an [NakshaError.ILLEGAL_STATE] error.
     * @param start the offset of the first row to include.
     * @param end the offset of the first row to exclude.
     * @return returns a handle that allows to read results between the given `offset`, and the given `end`, or _null_, if there are no more results (the new result-set would be empty).
     */
    fun createHandle(start: Int = offset(), end: Int = end()): String?
}