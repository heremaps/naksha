@file:Suppress("OPT_IN_USAGE")

package naksha.psql.executors

import naksha.model.NakshaError.NakshaErrorCompanion.ILLEGAL_STATE
import naksha.model.NakshaException
import naksha.model.request.ReadFeatures
import naksha.psql.PgConnection
import kotlin.js.JsExport
import kotlin.jvm.JvmField

/**
 * A query plan is created from a [ReadFeatures][naksha.model.request.ReadFeatures] request.
 *
 * All [queries][PgQuery] are ordered by `map`, `collectionId` and `table` in which they need to be executed. For example a query that is only executed against head, there will be either one query, or one query per partition. Some queries will directly know the partition to access, for example when reading features.
 *
 * The query will only select minimal information,
 */
@JsExport
class PgQueryPlan(
    /**
     * The read-features request from which to generate the queries.
     */
    @JvmField
    val readRequest: ReadFeatures,

    /**
     * If _false_, then the amount of queries is minimized, that means if possible, only one big query is build. If _true_, as many queries as possible are created, so that they can be executed in parallel. For example,
     */
    @JvmField
    val parallel: Boolean,

    /**
     * The _limit_ for the queries.
     */
    @JvmField
    val limit: Int
) {
    private var _queries: List<PgQuery>? = null

    /**
     * The queries that are the outcome of this plan. Available after [prepare] has been called.
     */
    val queries: List<PgQuery>
        get() = _queries ?: throw NakshaException(ILLEGAL_STATE, "Please invoke 'prepare' before accessing the queries.")

    private var _resultSet: PgResultSet? = null

    /**
     * The result-set generated by [finish].
     */
    val resultSet: PgResultSet
        get() = _resultSet ?: throw NakshaException(ILLEGAL_STATE, "Please invoke 'finish' before accessing the result-set.")

    /**
     * Prepares the query plan, basically generates the [queries].
     * @return this.
     */
    fun prepare(): PgQueryPlan {
        return this
    }

    /**
     * Helper method to execute all queries sequentially using the given connection.
     *
     * The client can either call this method, or create multiple threads and execute each individual query in parallel.
     * @param conn the connection to use to execute the query.
     * @param autoClose if _true_, the connection is closed after all queries are executed or when an exception raised.
     * @return this.
     */
    fun executeAll(conn: PgConnection, autoClose: Boolean = false) : PgQueryPlan {
        return this
    }

    /**
     *  Postprocess the individual results of the [queries], generating the final [resultSet].
     *
     *  Requires that all child queries have been executed, either via [executeAll] or a custom implementation.
     *  @return this.
     */
    fun finish() : PgQueryPlan {
        return this
    }
}